{"name":"Scala Datatable","tagline":"Immutable DataTable implementation in Scala","body":"#Scala DataTable\r\n\r\n## Overview\r\n\r\nScala DataTable is a lightweight, in-memory table structure written in Scala. The implementation is entirely immutable.\r\nModifying any part of the table, adding or removing columns, rows, or individual field values will create and return a\r\nnew structure, leaving the old one completely untouched. This is quite efficient due to structural sharing.\r\n\r\n### Features :\r\n * Fully immutable implementation.\r\n * All changes use structural sharing for performance.\r\n * Table columns can be added, inserted, updated and removed.\r\n * Rows can be added, inserted, updated and removed.\r\n * Individual cell values can be updated.\r\n * Any inserts, updates or deletes keep the original structure completely unchanged.\r\n * Handles typed or untyped data.\r\n * Internal type checks and bounds checks to ensure data integrity.\r\n * RowData object allowing typed or untyped data access.\r\n * Full filtering and searching on row data.\r\n * Single and multi column quick sorting.\r\n * DataViews to store sets of filtered / sorted data.\r\n\r\n## Implementation\r\n\r\nThe main focus for this project was to have the flexibility of a standard mutable table with all the common requirements,\r\nadd / remove columns, add / remove rows, update cells and values in individual cells, but with the benefit of immutable\r\nand persistent data structures.\r\n\r\nIt allows access to the table data in a row / column format where the column data types may, or may not be known at\r\ndesign time, for example a table read from a database, a CSV file or other dynamic data source.\r\n\r\nInternally the data is stored as a collection of immutable Vector[T] ensuring type information is fully preserved, with\r\nchecks ensuring full type integrity is maintained at runtime.\r\n\r\nThe table data can be easily accessed, filtered and modified through a RowData object, providing a range of typed and\r\nuntyped methods depending on how much type info is known at design time.\r\n\r\nMost methods have both checked and unchecked versions. The checked ones perform additional bounds checking and return\r\nresults as a Try[T] with detailed error information. The unchecked ones will just return a [T] and throw an exception\r\non any out of bounds errors but with potentially faster access on a significantly large amount of updates.\r\n\r\n#Getting Scala DataTable\r\n\r\nIf you use SBT, you can include the following line into the build.sbt file.\r\n```scala\r\nlibraryDependencies += \"com.github.martincooper\" %% \"scala-datatable\" % \"0.5.0\"\r\n```\r\n\r\n# Example Usage\r\n\r\n## Creating DataTables\r\nTo create a new DataTable, create the DataColumns required (just specify a unique column name and\r\nthe data populating each one) as shown below.\r\n\r\n```scala\r\ndef createDataTable() : Try[DataTable] = {\r\n\r\n  // Data columns created using a unique column name and a collection of values.\r\n  val stringCol = new DataColumn[String](\"StringColumn\", (1 to 100).map(i => \"Cell Value \" + i))\r\n  val integerCol = new DataColumn[Int](\"IntegerColumn\", (1 to 100).map(i => i * 20))\r\n  val booleanCol = new DataColumn[Boolean](\"BooleanColumn\", (1 to 100).map(i => true))\r\n\r\n  // DataTable created with using a table name and a collection of Data Columns.\r\n  val dataTableOption = DataTable(\"NewTable\", Seq(stringCol, integerCol, booleanCol))\r\n\r\n  // If any of the columns fail validation (duplicate column names, or columns contain\r\n  // data of different lengths), then it'll return a Failure. Else Success[DataTable]\r\n  dataTableOption\r\n}\r\n```\r\n\r\n## Adding Columns\r\nTo add a new Column, create a new DataColumn and call the add method on the table.columns\r\ncollection. This will return a new DataTable structure including the additional column.\r\n\r\n```scala\r\ndef addColumn(dataTable: DataTable): Try[DataTable] = {\r\n\r\n  // Create a new column.\r\n  val stringCol = new DataColumn[String](\"New Column\", (1 to 100).map(i => \"Another \" + i))\r\n\r\n  // Call columns.add to return a new Try[DataTable] structure with the additional column.\r\n  val updatedTable = dataTable.columns.add(stringCol)\r\n\r\n  // If adding the additional column fails validation (duplicate column names, or columns\r\n  // contain data of different lengths), then it'll return a Failure. Else Success[DataTable]\r\n  updatedTable\r\n}\r\n```\r\n\r\n## Removing Columns\r\nTo remove a Column, call the remove method on the table.columns collection.\r\nThis will return a new DataTable structure with the column removed.\r\n\r\n```scala\r\ndef removeColumn(dataTable: DataTable): Try[DataTable] = {\r\n\r\n  // Call columns.remove to return a new DataTable structure with the additional column.\r\n  val updatedTable = dataTable.columns.remove(\"ColumnToRemove\")\r\n\r\n  // If removing the column fails validation (column name not found),\r\n  // then it'll return a Failure. Else Success[DataTable]\r\n  updatedTable\r\n}\r\n```\r\n\r\n## Row / Data Filtering\r\nAccess to the underlying data in the table the DataRow object can be used. This allows either typed or\r\nuntyped access depending if type info is known at design time. The DataTable object implements IndexSeq[DataRow]\r\nso supports the standard filter, map operations etc. To filter a table this can be done as follows...\r\n\r\n```scala\r\ndef filterData(dataTable: DataTable) = {\r\n\r\n  // Filter the data using the RowData object.\r\n  val dataRows = dataTable.filter(row => {\r\n    row.as[String](\"FirstName\").startsWith(\"Ma\") && row.as[Int](\"Age\") > 18\r\n  })\r\n\r\n  // Access the filtered results...\r\n  println(dataRows.length)\r\n\r\n  // Row data can be accessed using indexers with no type information...\r\n  dataRows.foreach(row => println(row(0).toString + \" : \" + row(1).toString))\r\n\r\n  // Or by specifying the columns by name and with full type info.\r\n  dataRows.foreach(row =>\r\n    println(row.as[String](\"AddressOne\") + \" : \" + row.as[Int](\"HouseNumber\")))\r\n}\r\n```\r\n\r\n## Row / Data Access\r\nDataRow has a number of ways to access the underlying data, depending on the amount of information\r\nknown at design time about the data and it's type. The simplest way with no type information is\r\ncalling .value, or .valueMap on the DataRow item.\r\n\r\n```scala\r\ndef simpleDataAccess(dataRow: DataRow) = {\r\n\r\n  // Calling dataRow.values returns a IndexedSeq[Any] of all values in the row.\r\n  println(dataRow.values)\r\n\r\n  // Calling dataRow.valueMap returns a Map[String, Any] of all values\r\n  // in the row mapping column name to value.\r\n  println(dataRow.valueMap)\r\n}\r\n```\r\n\r\nThe DataRow has additional type checked and bounds checked methods allowing safer and\r\nmore composable access to the underlying data.\r\n\r\n```scala\r\ndef typedAndCheckedDataAccess(dataRow: DataRow) = {\r\n\r\n  // Each .getAs[T] is type checked and bounds / column name\r\n  // checked so can be composed safely\r\n  val checkedValue = for {\r\n    name <- dataRow.getAs[String](\"FirstName\")\r\n    age <- dataRow.getAs[Int](\"Age\")\r\n  } yield name + \" is \" + age + \" years old.\"\r\n\r\n  checkedValue match {\r\n    case Success(value) => println(value)\r\n    case Failure(ex) => println(\"Error occurred : \" + ex.getMessage)\r\n  }\r\n}\r\n```\r\n\r\n## Sorting / Single and Multi Column\r\nA DataTable can sort by specified column or columns, returning a sorted DataView.\r\n\r\n```scala\r\ndef sortTableByColumnNameDescending(dataTable: DataTable): Try[DataView] = {\r\n  dataTable.quickSort(\"ColumnOne\", Descending)\r\n}\r\n```\r\n\r\nAlso on multiple columns.\r\n\r\n```scala\r\ndef sortTableByMultipleColumns(dataTable: DataTable): Try[DataView] = {\r\n  val sortItemOne = SortItem(\"FirstName\")\r\n  val sortItemTwo = SortItem(3, Descending)\r\n  dataTable.quickSort(Seq(sortItemOne, sortItemTwo))\r\n}\r\n```\r\n\r\n### Additional Examples :\r\n * [Data Access with the DataRow](https://github.com/martincooper/scala-datatable/blob/master/docs/DataRowExamples.md)\r\n * [Modifying Data Columns](https://github.com/martincooper/scala-datatable/blob/master/docs/DataColumnModificationExamples.md)\r\n * [Sorting Data](https://github.com/martincooper/scala-datatable/blob/master/docs/SortingDataExamples.md)\r\n\r\n### Contributing\r\n\r\nBuilding this project requires SBT 0.13.0.\r\n\r\nAfter you launch SBT, you can run the following commands:\r\n\r\n * `compile` compile the project\r\n * `test` run the tests\r\n * `console` load a scala REPL with Scala DataTable on the classpath.\r\n\r\nTests are written with [ScalaTest](http://www.scalatest.org/)\r\n\r\n### Credits\r\n\r\nScala DataTable is maintained by Martin Cooper : Copyright (c) 2014-2015\r\n\r\n## License\r\n\r\n[Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}